#ifndef _QALGORITHMS_QBIN_INCLUDED
#define _QALGORITHMS_QBIN_INCLUDED

#include <vector>
#include <string>

#include "qalgorithms_datatypes.h"

namespace qAlgorithms
{
    // ####################################################################################################### //

    /// @brief wrapper function to execute qbinning on a std::vector<CentroidPeak> struct
    /// @param centroidedData centroid vector generated by qPeaks.passToBinning(...), defined in qalgorithms_qpeaks.cpp
    /// @param convertRT vector containing the retention time for every scan number
    /// @param verbose if this option is selected, additional progress report is written to standard out
    /// @return returns the centroids as a collection of vectors
    std::vector<EIC> performQbinning(const std::vector<CentroidPeak> *centroidedData,
                                     const std::vector<unsigned int> *convertRT);

    // ###################################################################################################### //
#pragma region "utility"

    /// @brief calculate the mean distance in mz to all other close elements of a sorted vector for one element
    /// @param pointsInBin vector of data points sorted by scans
    /// @return vector of the mean inner distances for all elements in the same order as pointsInBin
    std::vector<float> meanDistanceRegional(const std::vector<const CentroidPeak *> *pointsInBin,
                                            const size_t expandedDist);

    /// @brief calculate the data quality score as described by Reuschenbach et al. for one datapoint in a bin
    /// @param MID mean inner distance in mz to all other elements in the bin
    /// @param MOD minimum outer distance - the shortest distance in mz to a data point that is within maxdist and not in the bin
    /// @return the data quality score for the specified element
    inline float calcDQS(const float MID, const float MOD); // Mean Inner Distance, Minimum Outer Distance

#pragma endregion "utility"

#pragma region "Bin"

    // Bin Class
    class Bin
    {
    public:
        std::vector<const CentroidPeak *> pointsInBin;
        std::vector<float> DQSB_base;   // DQSB when all distances are considered equal @todo remove this eventually
        std::vector<float> DQSB_scaled; // DQSB if a gaussian falloff is assumed

        float mzMin = -1;
        float mzMax = -1;
        unsigned int scanMin = -1;
        unsigned int scanMax = -1;
        float medianMZ = -1; // only used for removing duplicates

        bool unchanged = false;     // if this is true after every test has run once, the bin is viable
        bool duplicateScan = false; // are two points with the same scan number in this bin?
        bool l_maxdist_tooclose = false;
        bool r_maxdist_tooclose = false; // Check if there is a point within maxdist

        /// @brief generate a bin that is a subset of an existing bin using two iterators.
        /// @details since this extracts a continuous sequence, it is only a good idea
        /// to construct a new bin like this after a completed subsetting step.
        /// @param startBin left border of the new bin
        /// @param endBin right border of the new bin
        Bin(const std::vector<const CentroidPeak *>::iterator &binStartInOS, const std::vector<const CentroidPeak *>::iterator &binEndInOS);

        Bin();

        /// @brief divide a bin sorted by mz the difference in mz of its members and return the new bins to the bin deque. Recursive function.
        /// @details this function iterates over the order space of a previously generated bin by searching for the maximum
        /// of the order space between startBin and endBin. If the maximum is smaller than the critical value, all data points
        /// between startBin and endBin are added to bincontainer as a new bin. The function terminates if it is called on less
        /// than five datapoints. For details on the critical value, see: "qBinning: Data Quality-Based Algorithm for Automized Ion Chromatogram
        /// Extraction from High-Resolution Mass Spectrometry. Max Reuschenbach, Felix Drees, Torsten C. Schmidt, and Gerrit Renner. Analytical
        /// Chemistry 2023 95 (37), 13804-13812. DOI: 10.1021/acs.analchem.3c01079"
        /// https://pubs.acs.org/doi/suppl/10.1021/acs.analchem.3c01079/suppl_file/ac3c01079_si_001.pdf page 26
        /// Assuming an order space [1,1,1,1,1,1,1,5,1,1,1] and a critical value of 4 for n = 11 (this does not reflect the actual critical value),
        /// the function would add a bin containing the datapoints 0 to 5 in the source bin to the bin deque
        /// @param bincontainer the newly created bins will be added to the back of this deque
        /// @param OS the order space generated for the bin using makeOS()
        /// @param startBin index relating to the order space at which the bin starts
        /// @param endBin index relating to the order space at which the bin ends
        void subsetMZ(std::vector<Bin> *bincontainer, std::vector<const CentroidPeak *> &notInBins,
                      const std::vector<double> &OS, const std::vector<double> &cumError,
                      const unsigned int binStartInOS, const unsigned int binEndInOS);

        /// @brief divide a bin sorted by scans if there are gaps greater than maxdist in it. Bins that cannot be divided are closed.
        /// @details this function sorts all members of a bin by scans and iterates over them. If a gap greater than maxdist exists,
        /// the bin is split at this point. Only subsets with more than five elements are added to the bin deque. If a bin is not split,
        /// it is added to the finishedBins vector and no further subsets will be performed on it. As such, subsetScan() must be the last
        /// subset function and cannot be used in combination with any other subsetting function that decides if a bin is completed or not.
        /// @param bincontainer if the input bin was split, the newly created bins will be added to this
        void subsetScan(std::vector<Bin> *bincontainer, std::vector<const CentroidPeak *> *notInBins);

        // returns the start index of where in the sorted not-binned points the minimum start position is
        size_t makeDQSB(const std::vector<const CentroidPeak *> *notInBins, size_t idx_lowerLimit);

        EIC createEIC(const std::vector<unsigned int> *convertRT);
    };

    const std::vector<double> makeOrderSpace(const Bin *bin);

    const std::vector<double> makeCumError(const std::vector<const CentroidPeak *> *bin);

    bool binLimitsOK(Bin sourceBin, const std::vector<CentroidPeak> *rawdata);

    void interpolateEIC(EIC *eic);

#pragma endregion "Bin"

#pragma region "Bin Container"
    // BinContainer
    struct BinContainer
    {
        std::vector<Bin> processBinsF;               // bin target in the starting case
        std::vector<Bin> processBinsT;               // bin target one past the starting case
        std::vector<Bin> viableBins;                 // only includes bins which cannot be further subdivided
        std::vector<Bin> finalBins;                  // bins which have been confirmed to not include incorrect binning
        std::vector<const CentroidPeak *> notInBins; // this vector contains all points which are not included in bins
        bool readFrom = false;
        // pointers for use during subsetting loop
        std::vector<Bin> *sourceBins;
        std::vector<Bin> *targetBins;
    };

    void switchTarget(BinContainer *bincontainer);

    std::string subsetBins(BinContainer &bincontainer);

    // int selectRebin(BinContainer *bins, const std::vector<CentroidPeak> *rawdata);
    int selectRebin(BinContainer *bins, const std::vector<CentroidPeak> *rawdata);

    // remove points with duplicate scans from a bin by choosing the one closest to the median
    void deduplicateBin(std::vector<Bin> *target, std::vector<const CentroidPeak *> *notInBins, Bin bin);

    void removeMassJumps(std::vector<Bin> *target, std::vector<const CentroidPeak *> *notInBins, Bin bin);

#pragma endregion "Bin Container"

    bool massTraceStable(std::vector<float> massesBin, int idxStart, int idxEnd);
}

#endif